---
title: "Revisión: LCA y Determinantes del Compromiso"
subtitle: "Análisis Bivariado y Modelos Multinomiales Predictivos"
date: today
format:
  html:
    fig-width: 12
    fig-height: 8
    fig-format: retina
    fig-dpi: 300
    theme:
      - cosmo
      - custom.scss
    css: custom.scss
    toc: true
    toc-depth: 3
    toc-title: "En este documento"
    toc-location: right
execute:
  warning: false
  message: false
  output: asis

author: 
  - name: "Roberto Cantillan"
    affiliations: 
      - name: "Departamento de Sociología"
        department: "Facultad de Ciencias Sociales"
        institution: "Pontificia Universidad Católica de Chile"
        address: "Santiago, Chile"
        email: "rcantillan@uc.cl"

abstract: |
  Este documento profundiza en la caracterización sociológica de perfiles ambientales identificados mediante Modelos de Clases Latentes (LCA): Ambientalismo Moderado (60%), Modo de Vida Imperial (13%) y Ambientalismo Crítico (27%). Se propone y valida un nuevo **Gradiente de Compromiso Ambiental** de cuatro niveles que permite distinguir entre la *Adaptación Privada* (cambio conductual sin apoyo fiscal) y el *Compromiso Eco-Fiscal*. Mediante modelos de regresión logística multinomial ajustados por edad y nivel socioeconómico, se demuestra que la disposición al sacrificio personal desvinculada de la responsabilidad fiscal es un predictor clave para diferenciar los perfiles latentes, revelando tensiones importantes entre la conducta individual y el apoyo a políticas estructurales.

Keywords: [Clases Latentes, Adaptación Privada, Compromiso Eco-Fiscal, Sociología Ambiental, Regresión Multinomial]

categories:
  - Latent Class Analysis
  - Multinomial Regression
  - Environmental Sociology
  - Sustainable Behavior

citation: 
  container-title: "Documentos de Trabajo"
  type: article
  issued: 2025

image: "featured.jpg"
title-block-banner: featured.jpg
title-block-banner-color: "rgba(0, 0, 0, 0.8)"
title-block-style: default
---

```{r setup}
#| label: setup
#| include: false

# Librerías esenciales
library(here)
library(knitr)
library(kableExtra)
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(tibble)
library(haven) 
library(nnet)       # Para modelos multinomiales
library(ggeffects)  # Para efectos marginales
library(gtsummary)  # <--- LA CLAVE PARA TABLAS ELEGANTES
library(gt)         # Motor gráfico de tablas

# Configuración global
options(knitr.table.format = "html")

# Configurar idioma de gtsummary a español
theme_gtsummary_language("es")

# --- PALETA DE COLORES COHERENTE ---
mis_colores <- c(
  "Clase 1 (59.7%)" = "#E41A1C",  # Rojo
  "Clase 2 (13%)"   = "#377EB8",  # Azul
  "Clase 3 (27.4%)" = "#4DAF4A"   # Verde
)
```

# 1\. Introducción

Este documento presenta un análisis secuencial:

1.  **Recodificación:** Creación de gradientes de compromiso.
2.  **Tamizaje Bivariado:** Identificación de variables significativas.
3.  **Modelado Multivariado:** Tablas de regresión comparativas y gráficos de probabilidad.


# 2\. Carga y Recodificación

```{r carga-datos}
#| echo: true

rdata_file <- here("objects", "datos_recodificados_con_lca.RData")

if (!file.exists(rdata_file)) {
  stop("ERROR: No se encontró el archivo: ", rdata_file)
}
load(rdata_file) 

# --- RECODIFICACIÓN EXPERTA (Lógica Jerárquica) ---
datos <- datos %>%
  mutate(
    # CARNE
    nivel_compromiso_carne = case_when(
      as.numeric(A6A) == 3 ~ 4, 
      as.numeric(A6A) == 2 & (as.numeric(A6B1_1) == 1 | as.numeric(A6B2_2) == 1) ~ 3, 
      as.numeric(A6A) == 2 ~ 2, 
      as.numeric(A6A) == 1 ~ 1, 
      TRUE ~ NA_real_
    ),
    # INTERNET
    nivel_compromiso_internet = case_when(
      as.numeric(A7A) == 3 ~ 4,
      as.numeric(A7A) == 2 & (as.numeric(A7B1_1) == 1 | as.numeric(A7B2_1) == 1) ~ 3,
      as.numeric(A7A) == 2 ~ 2,
      as.numeric(A7A) == 1 ~ 1,
      TRUE ~ NA_real_
    )
  ) %>%
  mutate(
    nivel_compromiso_carne = factor(nivel_compromiso_carne, levels = 1:4,
                                    labels = c("1. Resistencia", "2. Adaptación Privada", 
                                               "3. Compromiso Eco-Fiscal", "4. Abandono Radical")),
    nivel_compromiso_internet = factor(nivel_compromiso_internet, levels = 1:4,
                                       labels = c("1. Resistencia", "2. Adaptación Privada", 
                                                  "3. Compromiso Eco-Fiscal", "4. Abandono Radical"))
  )
```

# 3\. Análisis Bivariado 

Se ha optado por transformar las combinaciones de conducta y disposición a pagar en una **variable ordinal de 4 niveles** por tres razones estadísticas y sociológicas fundamentales:
  
  1.  **Poder Estadístico y Robustez:**
  Las categorías intermedias originales (ej. "Status Quo + Pagar Triple") presentaban frecuencias marginales extremadamente bajas ($n < 30$), lo que viola los supuestos de las pruebas de Chi-cuadrado y genera inestabilidad en modelos de regresión. La nueva categorización garantiza grupos robustos con $n$ suficiente para el análisis inferencial.

2.  **Identificación de la "Adaptación Privada" (Nivel 2):**
  El análisis exploratorio reveló que el grupo mayoritario (\~28%) está dispuesto a modificar su conducta personal (consumir menos) pero rechaza los mecanismos fiscales (impuestos). Este grupo quedaba oculto o mal clasificado en escalas binarias tradicionales. La categoría 2 captura explícitamente este fenómeno de "individualización de la responsabilidad sin costo fiscal".

3.  **Linealidad del Compromiso (Gradiente):**
  La nueva variable ordena teóricamente la intensidad del sacrificio percibido:
  
* *Nivel 1:* Sin costo (Status Quo).
* *Nivel 2:* Costo de hábito / estilo de vida.
* *Nivel 3:* Costo de hábito + Costo económico.
* *Nivel 4:* Costo máximo (Abandono total).


```{r loop-bivariado}
#| results: asis
#| echo: false

# 1. Definir variables a evaluar
vars_check <- c(
  "nivel_compromiso_carne", 
  "nivel_compromiso_internet",
  "P5_RE_macro", "P6_RE_macro", "P8_high",
  "P3_10_high", "P9_6_high", "A5_1_want_less", "P9_5_high"
)
present <- vars_check[vars_check %in% names(datos)]

vars_significativas <- c()

# Función Test
run_test <- function(tab) {
  tab2 <- tab[rowSums(tab)>0, colSums(tab)>0, drop=FALSE]
  if(nrow(tab2)<2 || ncol(tab2)<2) return(list(p=NA, name="Insuficiente"))
  
  exp <- tryCatch(chisq.test(tab2)$expected, error=function(e) NULL)
  if(is.null(exp) || any(exp < 5)) {
    res <- tryCatch(chisq.test(tab2, simulate.p.value=TRUE, B=2000), error=function(e) NULL)
    return(list(p=if(!is.null(res)) res$p.value else NA, name="Chi-sq (Sim)"))
  } else {
    res <- chisq.test(tab2)
    return(list(p=res$p.value, name="Chi-sq Pearson"))
  }
}

for (v in present) {
  cat("\n### Variable:", v, "\n\n")
  
  dfc <- data.frame(clase = datos$clase_latente_factor, var = datos[[v]])
  dfc <- dfc[complete.cases(dfc), ]
  
  if (nrow(dfc) < 10) { cat("N insuficiente.\n\n---\n"); next }
  
  tab <- table(dfc$clase, dfc$var)
  
  print(kbl(tab, caption = paste("Frecuencias:", v), booktabs = TRUE) %>%
        kable_styling(full_width = FALSE, position = "left") %>%
        add_header_above(c("Clase Latente" = 1, "Categorías" = ncol(tab))))
  cat("\n\n")
  
  test_info <- run_test(tab)
  pval <- test_info$p
  
  cat("**Test:**", test_info$name, "| **p-value:**", format.pval(pval, digits=4), "\n\n")
  
  if (!is.na(pval) && pval < 0.05) {
    cat("> **RESULTADO SIGNIFICATIVO: Se incluirá en modelo multivariado.**\n\n")
    vars_significativas <- c(vars_significativas, v) 
    
    pct_df <- as.data.frame.matrix(prop.table(tab, 1)*100) %>%
      rownames_to_column("clase") %>%
      pivot_longer(-clase, names_to="cat", values_to="val")
    
    p <- ggplot(pct_df, aes(x=cat, y=clase, fill=val)) +
      geom_tile(color="white") +
      geom_text(aes(label=round(val,1)), color=ifelse(pct_df$val>50,"white","black"), size = 5) +
      scale_fill_gradient(low="#e6f5ff", high="#004c99") +
      theme_minimal(base_size = 14) + 
      theme(axis.text.x = element_text(angle=45, hjust=1))
    print(p)
  } else {
    cat("> Relación no significativa.\n")
  }
  cat("\n---\n")
}
```

# 4\. Modelado Multivariado (Variables Significativas)

En esta sección se ajustan modelos **Multinomiales** controlando por **Edad** y **Grupo Socioeconómico**.

Las tablas a continuación presentan los **Odds Ratios (OR)**.

  * **Referencia:** Clase 1 (59.7%).
  * Los coeficientes se presentan en columnas lado a lado para facilitar la comparación.

<!-- end list -->

```{r loop-multinomial}
#| results: asis
#| echo: false
#| fig-height: 9
#| fig-width: 14

if (length(vars_significativas) == 0) {
  cat("No se encontraron variables significativas para modelar.")
} else {
  
  try({
    datos$clase_latente_factor <- relevel(datos$clase_latente_factor, ref = "Clase 1 (59.7%)")
  }, silent = TRUE)
  
  for (var_dep in vars_significativas) {
    
    cat("\n## Predictor: ", var_dep, "\n\n")
    
    # 1. Ajustar Modelo
    formula_modelo <- as.formula(paste("clase_latente_factor ~", var_dep, "+ Edad_rangos + GSE_Abrev"))
    modelo <- multinom(formula_modelo, data = datos, trace = FALSE, maxit = 1000)
    
    # 2. TABLA DE REGRESIÓN MEJORADA (GTSUMMARY)
    # Genera columnas lado a lado automáticamente para multinomial
    cat("### Tabla de Regresión (Odds Ratios)\n")
    
    tabla_reg <- tbl_regression(modelo, exponentiate = TRUE) %>% 
      bold_p() %>%
      modify_header(label = "**Variable**") %>%
      as_gt() %>%
      tab_options(table.font.size = 16) # Tamaño de letra de la tabla
      
    print(tabla_reg)
    cat("\n\n")
    
    # 3. PREDICCIONES
    term_call <- paste0(var_dep, " [all]") 
    pred_data <- ggpredict(modelo, terms = term_call)
    
    # 4. VISUALIZACIÓN GIGANTE
    cat("### Probabilidades Predichas (Visualización)\n")
    
    p_barras <- ggplot(pred_data, aes(x = x, y = predicted, fill = response.level)) +
      geom_col(position = position_dodge(width = 0.8), width = 0.7, color = "white") +
      
      geom_text(aes(label = scales::percent(predicted, accuracy = 0.1)),
                position = position_dodge(width = 0.8),
                vjust = -0.5, 
                size = 6,    
                fontface = "bold") +
      
      scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1.1), expand = c(0,0)) +
      scale_fill_manual(values = mis_colores, name = "Clase Latente") + 
      
      labs(
        title = paste("Efecto de", var_dep, "en la Clase Latente"),
        subtitle = "Probabilidad predicha ajustada por Edad y GSE",
        x = NULL,
        y = "Probabilidad Estimada"
      ) +
      
      theme_minimal(base_size = 18) + # Letra base gigante
      theme(
        plot.title = element_text(size = 24, face = "bold"),
        plot.subtitle = element_text(size = 18, color = "gray40", margin = margin(b = 20)),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16, face = "bold"), 
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.major.x = element_blank()
      )
    
    print(p_barras)
    cat("\n\n---\n")
  }
}
```

# 5\. Benchmark y caracterizacion

```{r}
#| label: benchmark-p3
#| results: asis
#| echo: false

# 1. Recodificación P3
datos <- datos %>%
  mutate(across(starts_with("P3_"), 
                ~case_when(
                  as.numeric(.) >= 4 ~ "High",
                  as.numeric(.) < 4  ~ "Low",
                  TRUE ~ NA_character_
                ),
                .names = "{.col}_high"))

cat("# 5. Benchmark de Dimensiones Ambientales (P3)\n")

vars_p3 <- paste0("P3_", 1:10, "_high")
present_p3 <- vars_p3[vars_p3 %in% names(datos)]

for (v in present_p3) {
  cat("\n## Variable:", v, "\n\n")
  
  df_p3 <- datos %>% 
    select(clase = clase_latente_factor, var = all_of(v)) %>% 
    drop_na()
  
  if (nrow(df_p3) > 0) {
    tab_frec <- table(df_p3$clase, df_p3$var)
    chi_test <- chisq.test(tab_frec, simulate.p.value = TRUE)
    
    print(kbl(tab_frec, caption = paste("Frecuencias (N):", v), booktabs = TRUE) %>%
            kable_styling(full_width = FALSE, position = "left"))
    
    cat("\n**Test:** Chi-sq Pearson | **p-value:**", format.pval(chi_test$p.value, digits=4), "\n\n")
    
    df_plot <- df_p3 %>%
      group_by(clase, var) %>%
      summarise(n = n(), .groups = 'drop') %>%
      group_by(clase) %>%
      mutate(pct = n / sum(n))
    
    p <- ggplot(df_plot, aes(x = clase, y = n, fill = var)) +
      geom_col(position = "fill", alpha = 0.85, width = 0.7) +
      geom_text(aes(label = paste0(round(pct*100, 1), "%\n(n=", n, ")")),
                position = position_fill(vjust = 0.5), size = 3.5, fontface = "bold", color = "white") +
      scale_y_continuous(labels = scales::percent_format(), expand = c(0,0)) +
      scale_fill_manual(values = c("High" = "#2c7bb6", "Low" = "#abd9e9"), name = "Respuesta") +
      theme_minimal(base_size = 14) +
      theme(legend.position = "top", panel.grid.major.x = element_blank())
    
    print(p)
  }
  cat("\n---\n")
}
```


```{r}
#| label: tabla-sociodemografica
#| results: asis
#| echo: false

cat("\n# 6. Caracterización Sociodemográfica de los Perfiles\n")

# 1. Preparación de datos con tus covariables exactas
datos_modelo <- datos %>%
  mutate(
    # Variable de Clase Social solicitada
    clase_social = if(exists("clase_social_cat")) clase_social_cat else datos_clase$clase_social_cat,
    
    # Categorización de edad basada en M5
    edad = case_when(
      M5 >= 18 & M5 <= 24 ~ 1,
      M5 >= 25 & M5 <= 34 ~ 2,
      M5 >= 35 & M5 <= 44 ~ 3,
      M5 >= 45 & M5 <= 54 ~ 4,
      M5 >= 55 & M5 <= 64 ~ 5,
      M5 >= 65 ~ 6,
      TRUE ~ NA_real_
    ),
    edad = factor(edad, 
                  levels = c(1, 2, 3, 4, 5, 6),
                  labels = c("18 a 24 años", "25 a 34 años", "35 a 44 años", 
                             "45 a 54 años", "55 a 64 años", "65 años o más")),
    
    # Sexo (M1)
    sexo = factor(M1, levels = 1:2, labels = c("Hombre", "Mujer")),
    
    # Posición política recodificada (M11)
    posicion_politica = case_when(
      M11 >= 1 & M11 <= 4 ~ "Izquierda",
      M11 >= 5 & M11 <= 6 ~ "Centro",
      M11 >= 7 & M11 <= 10 ~ "Derecha",
      TRUE ~ NA_character_
    ),
    posicion_politica = factor(posicion_politica, levels = c("Izquierda", "Centro", "Derecha")),
    
    # Rural/Urbano (M12)
    rural_urbano = factor(M12, levels = 1:3, labels = c("Urbano", "Rural", "Mixto"))
  )

# 2. Generación de la Tabla de Caracterización
tabla_socio <- datos_modelo %>%
  select(clase_latente_factor, sexo, edad, clase_social, posicion_politica, rural_urbano) %>%
  tbl_summary(
    by = clase_latente_factor,
    percent = "column",
    missing = "no",
    label = list(
      sexo ~ "Sexo",
      edad ~ "Tramo de Edad",
      clase_social ~ "Clase Social (Categoría)",
      posicion_politica ~ "Posición Política",
      rural_urbano ~ "Zona de Residencia"
    )
  ) %>%
  add_p() %>% # Test estadístico de diferencia entre clases
  bold_labels() %>%
  modify_spanning_header(all_stat_cols() ~ "**Perfiles LCA**") %>%
  as_gt() %>%
  tab_header(
    title = "Tabla: Caracterización Sociodemográfica por Clase Latente",
    subtitle = "Distribución porcentual de covariables estructurales y políticas"
  )

# Mostrar tabla
tabla_socio
```

# 6\. Tópicos

```{r}
#| label: stm-analisis-completo
#| fig-width: 12
#| fig-height: 14
#| warning: false
#| message: false

# 1. LIBRERÍAS
library(stm)
library(quanteda)
library(tidytext)
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(forcats)

cat("\n# 7. Modelamiento de Tópicos: Contenido y Prevalencia\n")

# 2. PREPARACIÓN Y LIMPIEZA PROFUNDA
col_texto <- intersect(names(datos), c("P1", "P1_abierta", "frase_sustentabilidad"))[1]

stop_words_custom <- c(
  stopwords("es"), "algo", "que", "con", "del", "una", "para", "los", "las", "como", 
  "esta", "tiene", "puede", "pueda", "mismo", "solo", "cosas", "nada", "manera", 
  "bien", "sirve", "maneras", "hace", "donde", "cuando", "pero", "estos", "estas"
)

datos_prepro <- datos %>%
  rename(texto = all_of(col_texto)) %>%
  select(texto, clase_latente_factor) %>%
  drop_na(texto) %>%
  mutate(texto = str_to_lower(texto),
         texto = str_replace_all(texto, "[[:punct:]]", " "),
         texto = str_squish(texto))

# 3. CREACIÓN DEL OBJETO STM
corpus_stm <- corpus(datos_prepro, text_field = "texto")
tokens_stm <- tokens(corpus_stm) %>%
  tokens_remove(stop_words_custom) %>%
  tokens_keep(min_nchar = 4)

dfm_stm <- dfm(tokens_stm) %>%
  dfm_trim(min_docfreq = 2)

out <- convert(dfm_stm, to = "stm")

# 4. ESTIMACIÓN DEL MODELO STM (K=4)
# La clase latente predice la probabilidad de cada tópico
modelo_stm <- stm(documents = out$documents, 
                  vocab = out$vocab, 
                  data = out$meta,
                  K = 4, 
                  prevalence =~ clase_latente_factor, 
                  verbose = FALSE, 
                  init.type = "Spectral")

# ------------------------------------------------------------------------------
# 5. VISUALIZACIÓN A: CONTENIDO DE LOS TÓPICOS (BETA)
# ------------------------------------------------------------------------------
td_beta <- tidy(modelo_stm, matrix = "beta")

p_beta <- td_beta %>%
  group_by(topic) %>%
  slice_max(beta, n = 10) %>%
  ungroup() %>%
  mutate(term = reorder_within(term, beta, topic)) %>%
  ggplot(aes(beta, term, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ paste("Tópico", topic), scales = "free") +
  scale_y_reordered() +
  labs(title = "Contenido de los Tópicos (Probabilidad Beta)",
       subtitle = "Términos que definen cada 'bolsa de sentido'",
       x = "Beta (Probabilidad de la palabra en el tópico)", y = NULL) +
  theme_minimal(base_size = 13)

print(p_beta)

# ------------------------------------------------------------------------------
# 6. VISUALIZACIÓN B: DIFERENCIAS DISCURSIVAS POR CLASE (GAMMA)
# ------------------------------------------------------------------------------
# Estimación de efectos
efectos <- estimateEffect(1:4 ~ clase_latente_factor, 
                          stmobj = modelo_stm, 
                          metadata = out$meta)

# Extracción manual de datos para ggplot2 (Solución al error 4, 3)
prep <- plot(efectos, "clase_latente_factor", method = "pointestimate", omitPlot = TRUE)

df_efectos <- data.frame()
for (i in seq_along(prep$topics)) {
  n_classes <- length(prep$uvals)
  temp_df <- data.frame(
    topic    = rep(prep$topics[i], n_classes),
    clase    = prep$uvals,
    estimate = as.numeric(prep$means[[i]]),
    lower    = as.numeric(prep$cis[[i]][1, ]),
    upper    = as.numeric(prep$cis[[i]][2, ])
  )
  df_efectos <- rbind(df_efectos, temp_df)
}

# Etiquetas dinámicas basadas en los resultados
etiquetas <- c(
  "1" = "Tópico 1: Recursos Naturales\n(medio, ambiente, agua)",
  "2" = "Tópico 2: Acción Individual\n(reciclaje, cuidar, acciones)",
  "3" = "Tópico 3: Bienestar Social\n(bueno, beneficioso, sustento)",
  "4" = "Tópico 4: Visión Sistémica\n(tiempo, mantener, perdura)"
)
df_efectos$topic_label <- etiquetas[as.character(df_efectos$topic)]

# Gráfico final de efectos
p_efectos <- ggplot(df_efectos, aes(x = estimate, y = topic_label, color = clase)) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = lower, xmax = upper), 
                 height = 0.3, size = 1.1, 
                 position = position_dodge(width = 0.5)) +
  scale_color_manual(values = mis_colores) + # Rojo, Azul, Verde
  labs(
    title = "Diferencias en el Discurso sobre Sustentabilidad",
    subtitle = "Probabilidad predicha según Clase Latente (STM con Covariables)",
    x = "Probabilidad Estimada del Tópico",
    y = NULL, color = "Clase Latente"
  ) +
  theme_minimal(base_size = 15) +
  theme(legend.position = "top", 
        axis.text.y = element_text(face = "bold", color = "black"),
        plot.title = element_text(face = "bold"))

print(p_efectos)
```



